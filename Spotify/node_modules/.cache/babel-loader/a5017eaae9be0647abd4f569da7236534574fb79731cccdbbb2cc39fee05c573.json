{"ast":null,"code":"'use strict';\n\nconst FS = require('fs');\nconst PATH = require('path');\nconst constants = {\n  DIRECTORY: 'directory',\n  FILE: 'file'\n};\nfunction safeReadDirSync(path) {\n  let dirData = {};\n  try {\n    dirData = FS.readdirSync(path);\n  } catch (ex) {\n    if (ex.code == \"EACCES\" || ex.code == \"EPERM\") {\n      //User does not have permissions, ignore directory\n      return null;\n    } else throw ex;\n  }\n  return dirData;\n}\n\n/**\n * Normalizes windows style paths by replacing double backslahes with single forward slahes (unix style).\n * @param  {string} path\n * @return {string}\n */\nfunction normalizePath(path) {\n  return path.replace(/\\\\/g, '/');\n}\n\n/**\n * Tests if the supplied parameter is of type RegExp\n * @param  {any}  regExp\n * @return {Boolean}\n */\nfunction isRegExp(regExp) {\n  return typeof regExp === \"object\" && regExp.constructor == RegExp;\n}\n\n/**\n * Collects the files and folders for a directory path into an Object, subject\n * to the options supplied, and invoking optional\n * @param  {String} path\n * @param  {Object} options\n * @param  {function} onEachFile\n * @param  {function} onEachDirectory\n * @return {Object}\n */\nfunction directoryTree(path, options, onEachFile, onEachDirectory) {\n  let currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  options = options || {};\n  if (options.depth !== undefined && options.attributes && options.attributes.indexOf('size') !== -1) {\n    throw new Error('usage of size attribute with depth option is prohibited');\n  }\n  const name = PATH.basename(path);\n  path = options.normalizePath ? normalizePath(path) : path;\n  const item = {\n    path,\n    name\n  };\n  let stats;\n  let lstat;\n  try {\n    stats = FS.statSync(path);\n    lstat = FS.lstatSync(path);\n  } catch (e) {\n    return null;\n  }\n\n  // Skip if it matches the exclude regex\n  if (options.exclude) {\n    const excludes = isRegExp(options.exclude) ? [options.exclude] : options.exclude;\n    if (excludes.some(exclusion => exclusion.test(path))) {\n      return null;\n    }\n  }\n  if (lstat.isSymbolicLink()) {\n    item.isSymbolicLink = true;\n    // Skip if symbolic links should not be followed\n    if (options.followSymlinks === false) return null;\n    // Initialize the symbolic links array to avoid infinite loops\n    if (!options.symlinks) options = {\n      ...options,\n      symlinks: []\n    };\n    // Skip if a cyclic symbolic link has been found\n    if (options.symlinks.find(ino => ino === lstat.ino)) {\n      return null;\n    } else {\n      options.symlinks.push(lstat.ino);\n    }\n  }\n  if (stats.isFile()) {\n    const ext = PATH.extname(path).toLowerCase();\n\n    // Skip if it does not match the extension regex\n    if (options.extensions && !options.extensions.test(ext)) return null;\n    if (options.attributes) {\n      options.attributes.forEach(attribute => {\n        switch (attribute) {\n          case 'extension':\n            item.extension = ext;\n            break;\n          case 'type':\n            item.type = constants.FILE;\n            break;\n          default:\n            item[attribute] = stats[attribute];\n            break;\n        }\n      });\n    }\n    if (onEachFile) {\n      onEachFile(item, path, stats);\n    }\n  } else if (stats.isDirectory()) {\n    let dirData = safeReadDirSync(path);\n    if (dirData === null) return null;\n    if (options.depth === undefined || options.depth > currentDepth) {\n      item.children = dirData.map(child => directoryTree(PATH.join(path, child), options, onEachFile, onEachDirectory, currentDepth + 1)).filter(e => !!e);\n    }\n    if (options.attributes) {\n      options.attributes.forEach(attribute => {\n        switch (attribute) {\n          case 'size':\n            item.size = item.children.reduce((prev, cur) => prev + cur.size, 0);\n            break;\n          case 'type':\n            item.type = constants.DIRECTORY;\n            break;\n          case 'extension':\n            break;\n          default:\n            item[attribute] = stats[attribute];\n            break;\n        }\n      });\n    }\n    if (onEachDirectory) {\n      onEachDirectory(item, path, stats);\n    }\n  } else {\n    return null; // Or set item.size = 0 for devices, FIFO and sockets ?\n  }\n\n  return item;\n}\nmodule.exports = directoryTree;","map":{"version":3,"names":["FS","require","PATH","constants","DIRECTORY","FILE","safeReadDirSync","path","dirData","readdirSync","ex","code","normalizePath","replace","isRegExp","regExp","constructor","RegExp","directoryTree","options","onEachFile","onEachDirectory","currentDepth","depth","undefined","attributes","indexOf","Error","name","basename","item","stats","lstat","statSync","lstatSync","e","exclude","excludes","some","exclusion","test","isSymbolicLink","followSymlinks","symlinks","find","ino","push","isFile","ext","extname","toLowerCase","extensions","forEach","attribute","extension","type","isDirectory","children","map","child","join","filter","size","reduce","prev","cur","module","exports"],"sources":["C:/Users/Alex/Documents/library-app/03-frontend/react-libary/node_modules/directory-tree/lib/directory-tree.js"],"sourcesContent":["'use strict';\n\nconst FS = require('fs');\nconst PATH = require('path');\nconst constants = {\n  DIRECTORY: 'directory',\n  FILE: 'file'\n}\n\nfunction safeReadDirSync (path) {\n  let dirData = {};\n  try {\n    dirData = FS.readdirSync(path);\n  } catch(ex) {\n    if (ex.code == \"EACCES\" || ex.code == \"EPERM\") {\n      //User does not have permissions, ignore directory\n      return null;\n    }\n    else throw ex;\n  }\n  return dirData;\n}\n\n/**\n * Normalizes windows style paths by replacing double backslahes with single forward slahes (unix style).\n * @param  {string} path\n * @return {string}\n */\nfunction normalizePath(path) {\n  return path.replace(/\\\\/g, '/');\n}\n\n/**\n * Tests if the supplied parameter is of type RegExp\n * @param  {any}  regExp\n * @return {Boolean}\n */\nfunction isRegExp(regExp) {\n  return typeof regExp === \"object\" && regExp.constructor == RegExp;\n}\n\n/**\n * Collects the files and folders for a directory path into an Object, subject\n * to the options supplied, and invoking optional\n * @param  {String} path\n * @param  {Object} options\n * @param  {function} onEachFile\n * @param  {function} onEachDirectory\n * @return {Object}\n */\nfunction directoryTree (path, options, onEachFile, onEachDirectory, currentDepth = 0) {\n  options = options || {};\n\n  if (options.depth !== undefined && options.attributes && options.attributes.indexOf('size') !== -1) {\n    throw new Error('usage of size attribute with depth option is prohibited');\n  }\n\n  const name = PATH.basename(path);\n  path = options.normalizePath ? normalizePath(path) : path;\n  const item = { path, name };\n  let stats;\n  let lstat;\n\n  try {\n    stats = FS.statSync(path);\n    lstat = FS.lstatSync(path);\n  }\n  catch (e) { return null }\n\n  // Skip if it matches the exclude regex\n  if (options.exclude) {\n    const excludes =  isRegExp(options.exclude) ? [options.exclude] : options.exclude;\n    if (excludes.some((exclusion) => exclusion.test(path))) {\n      return null;\n    }\n  }\n\n  if (lstat.isSymbolicLink()) {\n    item.isSymbolicLink = true;\n    // Skip if symbolic links should not be followed\n    if (options.followSymlinks === false)\n      return null;\n    // Initialize the symbolic links array to avoid infinite loops\n    if (!options.symlinks)\n      options = { ...options, symlinks: [] };\n    // Skip if a cyclic symbolic link has been found\n    if (options.symlinks.find(ino => ino === lstat.ino)) {\n      return null;\n    } else {\n      options.symlinks.push(lstat.ino);\n    }\n  }\n\n  if (stats.isFile()) {\n\n    const ext = PATH.extname(path).toLowerCase();\n\n    // Skip if it does not match the extension regex\n    if (options.extensions && !options.extensions.test(ext))\n      return null;\n\n\n    if (options.attributes) {\n      options.attributes.forEach((attribute) => {\n        switch (attribute) {\n          case 'extension':\n            item.extension = ext;\n            break;\n          case 'type':\n            item.type = constants.FILE;\n            break;\n          default:\n            item[attribute] = stats[attribute];\n            break;\n        }\n      });\n    }\n\n    if (onEachFile) {\n      onEachFile(item, path, stats);\n    }\n  }\n  else if (stats.isDirectory()) {\n    let dirData = safeReadDirSync(path);\n    if (dirData === null) return null;\n\n    if (options.depth === undefined || options.depth > currentDepth) {\n      item.children = dirData\n          .map(child => directoryTree(PATH.join(path, child), options, onEachFile, onEachDirectory, currentDepth + 1))\n          .filter(e => !!e);\n    }\n\n    if (options.attributes) {\n      options.attributes.forEach((attribute) => {\n        switch (attribute) {\n          case 'size':\n            item.size = item.children.reduce((prev, cur) => prev + cur.size, 0);\n            break;\n          case 'type':\n            item.type = constants.DIRECTORY;\n            break;\n          case 'extension':\n            break;\n          default:\n            item[attribute] = stats[attribute];\n            break;\n        }\n        \n      });\n    }\n\n    if (onEachDirectory) {\n      onEachDirectory(item, path, stats);\n    }\n  } else {\n    return null; // Or set item.size = 0 for devices, FIFO and sockets ?\n  }\n  return item;\n}\n\nmodule.exports = directoryTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}